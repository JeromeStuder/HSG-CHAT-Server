'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SocketSubject = undefined;

var _net = require('net');

var _os = require('os');

var _Observable = require('rxjs/Observable');

require('rxjs/Observer');

var _ReplaySubject = require('rxjs/ReplaySubject');

var _Subject = require('rxjs/Subject');

var _Subscriber = require('rxjs/Subscriber');

var _Subscription = require('rxjs/Subscription');

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

class SocketSubject extends _Subject.AnonymousSubject {

  constructor(connectArg, destination) {
    super();

    if (typeof connectArg === 'object') {
      const { openObserver, closeObserver } = connectArg,
            arg = _objectWithoutProperties(connectArg, ['openObserver', 'closeObserver']);
      this.openObserver = openObserver;
      this.closeObserver = closeObserver;
      this._connectArg = arg;
    } else {
      this._connectArg = connectArg;
    }

    this._output = new _Subject.Subject();
    // $FlowFixMe
    this.destination = new _ReplaySubject.ReplaySubject();
  }

  resultSelector(data) {
    return JSON.parse(data);
  }

  _reset() {
    this.socket = null;
    this._output = new _Subject.Subject();
  }

  _connectSocket() {
    const observer = this._output;

    const socket = (0, _net.createConnection)(this._connectArg);
    this.socket = socket;

    // $FlowFixMe
    const subscription = new _Subscription.Subscription(() => {
      socket.end();
      this.socket = null;
    });

    socket.on('connect', () => {
      if (this.openObserver) {
        this.openObserver.next();
      }

      const queue = this.destination;

      // $FlowFixMe
      this.destination = _Subscriber.Subscriber.create(x => {
        socket.write(x);
      }, e => {
        observer.error(e);
        this._reset();
      }, () => {
        socket.end();
        this._reset();
      });

      if (queue && queue instanceof _ReplaySubject.ReplaySubject) {
        subscription.add(queue.subscribe(this.destination));
      }
    });

    socket.on('close', had_error => {
      this._reset();
      this.closeObserver && this.closeObserver.next(had_error);
      if (had_error) {
        observer.error(new Error('Connection closed'));
      } else {
        observer.complete();
      }
    });

    const tryPush = str => {
      try {
        const result = this.resultSelector(str);
        observer.next(result);
      } catch (err) {
        observer.error(err);
      }
    };

    socket.on('data', data => {
      data.toString().split(_os.EOL).filter(Boolean).forEach(tryPush);
    });
  }

  _subscribe(subscriber) {
    if (!this.socket) {
      this._connectSocket();
    }

    const subscription = new _Subscription.Subscription();
    subscription.add(this._output.subscribe(subscriber));
    subscription.add(() => {
      if (this._output.observers.length === 0) {
        if (this.socket) {
          this.socket.end();
        }
        this._reset();
      }
    });
    return subscription;
  }

  unsubscribe() {
    if (this.socket) {
      this.socket.end();
      this._reset();
    }
    super.unsubscribe();
  }
}
exports.SocketSubject = SocketSubject;